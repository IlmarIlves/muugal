### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Admin {
  """Admin order by id"""
  order(
    """User identifier"""
    orderId: ID

    """Order price in cents"""
    priceInCents: Int
  ): AdminOrder!

  """Admin payment by id"""
  payment(
    """Payment identifier"""
    paymentId: ID
  ): AdminPayment!

  """List of users"""
  payments: AdminPayments!

  """Admin user by id"""
  user(
    """User identifier"""
    userId: ID
  ): AdminUser!

  """List of users"""
  users(filter: AdminUsersFilterInput, match: MatchInput, pagination: PaginationInput): AdminUsers!
}

type AdminOrder {
  """User role"""
  additionalInfo: String!

  """User role"""
  amount: Int!

  """User role"""
  colors: String!
  data: String!
  email: String!
  id: ID!
  mimeType: String!
  telephone: String!
  userId: ID!
}

type AdminOrders {
  """List of paginated orders"""
  orders: [AdminOrder!]!
}

type AdminPayment {
  """Payment amount"""
  amount: Int!

  """Payment currencyCode"""
  currencyCode: String!

  """Payment currencyCode"""
  emailUsedForPayment: String!

  """Payment unique id"""
  id: ID!

  """Payment status"""
  status: NEXUS__UNKNOWN__TYPE!

  """Payment user unique id"""
  stripeSessionId: String!

  """Payment user unique id"""
  userId: ID!
}

type AdminPayments {
  """List of paginated orders"""
  payments: [AdminPayment!]!
}

type AdminUser {
  email: String!
  firstName: String!
  id: ID!
  lastName: String!

  """User role"""
  userRole: [UserRoleEnum!]!

  """User status"""
  userStatus: UserStatusEnum!
}

type AdminUsers {
  skip: Int!
  take: Int!
  total: Int!

  """List of paginated users"""
  users: [AdminUser!]!
}

input AdminUsersFilterInput {
  """Filter users by email"""
  email: String

  """Filter users by first name"""
  firstName: String

  """Filter users by last name"""
  lastName: String

  """Filter users by id"""
  userId: String
}

enum ConditionModeEnum {
  AND
  OR
}

type LoginResponse {
  accessToken: String!
}

input MatchInput {
  conditionMode: ConditionModeEnum = AND
  matchMode: MatchModeEnum = STARTS_WITH
}

enum MatchModeEnum {
  CONTAINS
  EXACT
  STARTS_WITH
}

type Mutation {
  """Reset user password"""
  adminResetUserPassword(
    """User id"""
    userId: ID
  ): AdminUser!

  """Changes current user password"""
  changePassword(
    """Confirmation password"""
    confirmPassword: String

    """Current password"""
    currentPassword: String

    """New password"""
    newPassword: String
  ): Viewer!

  """Creates new Stripe checkout session"""
  createStripeCheckoutSession(
    """Product price"""
    priceInCents: Int

    """Product name"""
    productName: String

    """Product quantity"""
    quantity: Int
  ): NEXUS__UNKNOWN__TYPE!

  """Attempts to log user in"""
  login(
    """Email address"""
    email: String

    """Password"""
    password: String
  ): LoginResponse!

  """Logs out signed-in user if any"""
  logout: Boolean!

  """Uploads file"""
  order(
    """Upload file"""
    file: Upload
  ): Order!

  """Registers new user"""
  register(
    """Email address"""
    email: String

    """First name"""
    firstName: String

    """Last name"""
    lastName: String

    """Password"""
    password: String
  ): User!
}

"""

    This scalar should never make it into production. It is used as a placeholder for situations
    where GraphQL Nexus encounters a missing type. We don't want to error immedately, otherwise
    the TypeScript definitions will not be updated.
  
"""
scalar NEXUS__UNKNOWN__TYPE

type Order {
  """User role"""
  additionalInfo: String!

  """User role"""
  amount: Int!

  """User role"""
  colors: String!
  data: String!
  email: String!
  id: ID!
  mimeType: String!
  telephone: String!
  userId: ID!
}

input PaginationInput {
  """Number of items to skip"""
  skip: Int

  """Number of items to take"""
  take: Int
}

type Query {
  """Admin resolvers"""
  admin: Admin!

  """Query viewer"""
  viewer: User
}

"""File upload"""
scalar Upload

type User {
  email: String!
  firstName: String!
  id: ID!
  lastName: String!

  """User status"""
  userStatus: UserStatusEnum!
}

enum UserRoleEnum {
  ADMIN
  USER
}

enum UserStatusEnum {
  ACTIVE
  DEACTIVATED
  DISABLED
}

type Viewer {
  accessToken: String!
}
